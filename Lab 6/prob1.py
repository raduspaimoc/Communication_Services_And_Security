
def hex_to_bin(hexdec):
    """Convert hexadecimal to binary."""
    dec = int(hexdec, 16)
    binary_result = bin(dec)
    return binary_result[2:]


def crc(msg, div, code='00000000'):
    """Cyclic Redundancy Check
    Generates an error detecting code based on an inputted message
    and divisor in the form of a polynomial representation.
    Arguments:
        msg: The input message of which to generate the output code.
        div: The divisor in polynomial form. For example, if the polynomial
            of x^3 + x + 1 is given, this should be represented as '1011' in
            the div argument.
        code: This is an option argument where a previously generated code may
            be passed in. This can be used to check validity. If the inputted
            code produces an outputted code of all zeros, then the message has
            no errors.
    Returns:
        An error-detecting code generated by the message and the given divisor.
    """
    # Append the code to the message. If no code is given, default to '00000000'
    msg = msg + code

    # Convert msg and div into list form for easier handling
    msg = list(msg)
    div = list(div)

    # Loop over every message bit (minus the appended code)
    for i in range(len(msg)-len(code)):
        # If that messsage bit is 1, perform modulo 2 multiplication
        if msg[i] == '1':
            for j in range(len(div)):
                # Perform modulo 2 multiplication on each index of the divisor
                msg[i+j] = str((int(msg[i+j])+int(div[j]))%2)
    
    # Output the last error-checking code portion of the message generated
    return ''.join(msg[-len(code):])

def xor(num1, num2):
    """XOR two binary numbers."""
    # Same bit = 0 diferent bit = 1
    y = int(num1, 2)^int(num2,2)

    max_size = max(len(num1),len(num2))
    xor_result = bin(y)[2:].zfill(max_size)

    return xor_result


def pseudo_random_noise_generators(key, init_vector, text):
    """
    Arguments:
        key  -- Key used
        init_vector  -- IV
        text -- information to be ciphered

    Returns: String of the output bits
    """

    PO = []
    PS = []
    
    for i in range(0, len(text)):
        if i == 0:
            # PS(0) = init_vector (+) key
            PS = list(xor(init_vector, key))
        
        else:	
            prev_PS = PS.copy()
            for j in range(0, len(PS)):
                
                if j == 0:
                    # PS(i)[0] = PS(i − 1)[4] (+) PS(i − 1)[7]
                    PS[j] = xor(prev_PS[4], prev_PS[7])
                else:
                    # PS(i)[j] = PS(i−1)[j−1], j>0
                    PS[j] = prev_PS[j-1]
                
        # PO[i] = PS(i)[4] (+) PS(i)[7]
        PO.append(xor(PS[4], PS[7]))
        
    return "".join(PO)



def WEP_cipher(text, key, init_vector):
    """
    Arguments:
        text -- information to be ciphered or deciphered
        key  -- Key used
        init_vector  -- IV

    Returns:
        result -- ciphered or deciphered text
    """
    PRNG = pseudo_random_noise_generators(key, init_vector, text)
    result = xor(PRNG, text)

    return result

def print_basic_info():
    print("Initial data")
    print("clear_text: "+ clear_text)
    print("key: "+ key)
    print("init_vector: "+ init_vector)
    print("expected_cipher: "+ expected_cipher)
    print("")

def validation(event, generated, expected):
    """Validation to check that generated is equal to expected."""

    print(event, " generated: " + generated + ", expected: " + expected)
    print(event, " SUCCESS: " + str(generated == expected))

if __name__ == '__main__':

    clear_text = hex_to_bin("0x0123").zfill(16)
    key = hex_to_bin("0x33").zfill(8)
    init_vector = hex_to_bin("0x11").zfill(8)
    expected_cipher = hex_to_bin("0x667E92").zfill(24)
    print_basic_info()

    # x^8 + 1
    div = "100000001"

    # CRC Calculation
    crc_code = crc(clear_text, div)


    # Cipher text
    text_to_cipher = clear_text + crc_code
    cipher_text = WEP_cipher(text_to_cipher, key, init_vector)

    print("\nCipher validation")
    validation("Cipher", str(cipher_text), str(expected_cipher))


    # Descipher with correct key
    deciphered_data = WEP_cipher(cipher_text, key, init_vector)

    print("\nDecipher validation with correct key")
    validation("Decipher", str(deciphered_data), str(text_to_cipher))
    print('CRC Success:', crc(deciphered_data[:16], div, crc_code) == '00000000')
    

    # Descipher with wrong key
    wrong_key = hex_to_bin("0x22").zfill(8)
    deciphered_data = WEP_cipher(cipher_text, wrong_key, init_vector)

    print("\nDecipher validation with wrong key (Have to return Success = false)")
    validation("Decipher", str(deciphered_data), str(text_to_cipher))
    print('CRC Success:', crc(deciphered_data[:16], div, crc_code) == '00000000')
